---
title: "Drift and mutation"
output: html_notebook
---

exact calculations^[Fu, R., A.E. Gelfand, and K.E. Holsinger.  2003.  Exact moment calculations for genetic models with migration, mutation, and drift. *Theoretical Population Biology* 63:231-243 doi: [10.1016/s0040-5809(03)00003-0 ](https://dx.doi.org/10.1016/s0040-5809(03)00003-0)]

Compare results from Latter^[Latter, B.D.H.  1973.  The island model of population differentiation: a general solution.  *Genetics*  73:147-157 doi: [10.1093/genetics/73.1.147](https://doi.org/10.1093/genetics/73.1.147)]

```{r}
rm(list = ls())

infinite_island <- function(n_e, m, mu) {
  return(1/(4*n_e*(m + mu) + 1))
}

r_mk <- function(m, k) {
  return((2*m - (m^2)*k)/(k-1))
}

## Note: assumes symmetric mutation
##
rho_k <- function(m, mu, k) {
  r <- r_mk(m, k)
  rho <- (r/(k-1))*(1 - 2*mu)^2/(1 - ((1 - 2*mu)^2)*(1 - r/(k-1)))
  return(rho)
}

## Note: assumes symmetric mutation
##
variance <- function(n_e, m, mu, n_islands) {
  p <- 1/2
  r <- r_mk(m, n_islands)
  rho <- rho_k(m, mu, n_islands) 
  s_squared <- p*(1-p)/(2*n_e - (2*n_e - 1)*((1 - 2*mu)^2)*(1 - r + r*rho))
  return(s_squared)
}

## Note: assumes symmetric mutation
##
finite_island <- function(n_e, m, mu, n_islands) {
  sigma_squared <- variance(n_e, m, mu, n_islands)
  rho <- rho_k(m, mu, n_islands)
  num <- ((n_islands - 1)/n_islands)*sigma_squared*(1 - rho)
  den <- (1/4) - (1/n_islands)*sigma_squared*(1 + (n_islands - 1)*rho)
  return(num/den)
}

lambda <- function(mu, m, k) {
  m_prime <- m*k/(k - 1)
  l <- (1/2)*((1 - mu)^(-2)*(1- m_prime)^(-2) - 1)
  return(l)
}

gamma <- function(mu, m, k) {
  m_prime <- m*k/(k - 1)
  g <- (1 + m_prime*(2 - m_prime)/(k*mu*(2 - mu)*(1 - m_prime)^2))^(-1)
  return(g)
}

latter <- function(n_e, m, mu, n_islands) {
  l <- lambda(mu, m, n_islands)
  g <- gamma(mu, m, n_islands)
  h_s <- 4*n_e*l*g/(4*n_e*l*g + 1)
  h_b <- h_s*(1 + 4*n_e*l)/(4*n_e*l)
  h_t <- ((n_islands - 1)/n_islands)*h_b + (1/n_islands)*h_s
  f_st <- (h_t - h_s)/h_t
  return(f_st)
}

dat <- data.frame(k = c(5, 25, 250, 2500),
  Infinite = c(infinite_island(100, 0.05, 0.000005),
               infinite_island(100, 0.05, 0.000005),
               infinite_island(100, 0.05, 0.000005),
               infinite_island(100, 0.05, 0.000005)),
  Finite = c(latter(100, 0.05, 0.000005, 5),
             latter(100, 0.05, 0.000005, 25),
             latter(100, 0.05, 0.000005, 250),
             latter(100, 0.05, 0.000005, 2500)))
dat
```

Interestingly the simulations produce values more consistent with the infinite island model expectatotion than with the finite model expectation from FGH. Latter matches pretty well. It must have to do with the reduced variation within a time step relative to the variation across time.

## Simulations

```{r}
library(tidyverse)
library(hierfstat)

initialize <- function(k, n_loci) {
  p <- array(dim = c(n_loci, k, 2))
  for (j in 1:n_loci) {
    for (i in 1:k) {
      p[j, i, 1] <- runif(n = 1, min = 0, max = 1)
      p[j, i, 2] <- 1 - p[j, i, 1]
    }
  }
  return(p)
}

make_symmetric_matrix <- function(m, k) {
  M <- diag(x = 1 - m, nrow = k)
  for (i in 1:(k - 1)) {
    for (j in (i+1):k) {
      M[i, j] <- m/(k-1)
      M[j, i] <- M[i, j]
    }
  }
  return(M)
}

sample_two_alleles <- function(p) {
  allele_1 <- ((runif(1) < p) + 1)*10
  allele_2 <- (runif(1) < p) + 1
  return(allele_1 + allele_2)
}

make_sample <- function(p, n_sample) {
  n_pops <- dim(p)[2]
  n_loci <- dim(p)[1]
  names <- paste("Locus", seq(1:n_loci), sep = "")
  pops <- numeric(n_pops*n_sample)
  ct <- 1
  for (k in 1:n_pops) {
    population <- paste("Population", k, sep = "")
    for (i in 1:n_sample) {
      pops[ct] <- population
      ct <- ct + 1
    }
  }
  locus_data <- matrix(nrow = n_pops*n_sample, ncol = n_loci)
  for (i in 1:n_loci) {
   ct <- 1
    for (k in 1:n_pops) {
      for (n in 1:n_sample) {
        locus_data[ct, i] <- sample_two_alleles(p[i, k, 1])
        ct <- ct + 1
      }
    }
  }
  df <- data.frame(locus_data)
  colnames(df) <- paste("Locus", seq(1:n_loci), sep = "")
  df$Population <- pops
  df <- relocate(df, Population)
  return(df)
}

simulate <- function(n_e, m, mu, n_islands, n_loci, n_gen, n_sample) {
  p <- initialize(n_islands, n_loci)
  M <- make_symmetric_matrix(m, n_islands)
  V <- make_symmetric_matrix(mu, 2)
  g_st <- numeric(n_loci)
  p_star <- array(dim = c(n_loci, n_islands, 2))
  for (i in 1:n_gen) {
    for (k in 1:n_loci) {
      p_star[k, , ] <- M %*% p[k, , ] %*% V
      for (j in 1:n_islands) {
        p[k, j, ] <- rmultinom(1, 2*n_e, p_star[k, j, ])/(2*n_e)
      }
      mu_p <- mean(p[k, , 1])
      g_st[k] <- ((n_islands - 1)/n_islands)*var(p[k, , 1])/(mu_p*(1 - mu_p))
    }
  }
  df <- make_sample(p, n_sample)
  return(wc(df)$FST)
}

run_simulation <- function(n_e, m, mu, n_islands, n_loci, n_gen, 
                           n_sample, n_repetitions)
{
  f_st <- numeric(n_repetitions)
  for (i in 1:n_repetitions) {
    if (n_repetitions > 50) {
      cat(".", sep="")
      if ((i %% 50) == 0) {
        cat(i, "\n", sep ="")
      }
    }
    f_st[i] <-simulate(n_e, m, mu, n_islands, n_loci, n_gen, n_sample)
  }
  return(f_st)
}

plot_simulation <- function(f_st, n_e, m, mu, n_islands) {
  df <- data.frame(F_st = f_st)
  p <- ggplot(df, aes(x = F_st)) +
    geom_histogram(bins = 20) +
    geom_vline(xintercept = infinite_island(n_e, m, mu),
               linetype = "dashed",
               color = "red") +
    ggtitle(paste("N_e = ", n_e, ", m = ", m, ", mu = ", mu, 
                  "n_islands = ", n_islands, sep = "")) +
    theme_bw()
  return(p)
}
```

## Trying a few combinations

```{r}
library(tictoc)

n_loci <- 10
n_sample <- 25
n_gen <- 1000
n_repetitions <- 10
tic()
df <- data.frame(N_e = NA, m = NA, mu = NA, n_islands = NA, observed = NA,
                 Infinite = NA, Finite = NA)
for (n_e in c(25, 100, 250, 500)) {
  for (m in c(0.05, 0.01, 0.005, 0.001)) {
    for (mu in c(0.001, 1e-4)) {
      for (n_islands in c(10, 25, 50)) {
        cat("N_e = ", n_e, ", m = ", m, ", mu = ", mu, 
            "n_islands = ", n_islands, "\n" )
        f_st <- run_simulation(n_e, m, mu, n_islands, n_loci, n_gen, 
                               n_sample, n_repetitions)
        df <- add_row(df, 
                      N_e = rep(n_e, n_repetitions),
                      m = rep(m, n_repetitions), 
                      mu = rep(mu, n_repetitions), 
                      n_islands = rep(n_islands, n_repetitions),
                      Observed = f_st,
                      Infinite = infinite_island(n_e, m, mu),
                      Finite = latter(n_e, m, mu, n_islands))
      }
    }
  }
}
df <- filter(df, !is.na(N_e))
toc()
```

Given 

$$
F_{ST} = \frac{1}{4N_e(m + \mu) + 1} \quad ,
$$
it's easy to see that

$$
\frac{1}{F_{ST}} = 4N_e(m + \mu) + 1 \quad .
$$
Thus, if we do a linear regression of $\frac{1}{F_{ST}}$ on $4N_e(m + \mu)$ we expect the slope of the regression to be 4 and the intercept to be 1. We can use `lm()` to run the regression.

```{r}
df$N_e_m_plus_mu <- df$N_e*(df$m + df$mu)
summary(lm(1/Observed ~ N_e_m_plus_mu, data = df))
p <- ggplot(df, aes(x = N_e_m_plus_mu, y = 1/Observed)) + 
     geom_point() + 
     geom_smooth(method = "lm", formula = "y ~ x") + 
     theme_bw()
p
p <- ggplot(df, aes(x = Infinite, y = Observed)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", 
              color = "red") + theme_bw()
p
p <- ggplot(df, aes(x = Finite, y = Observed)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", 
              color = "red") + theme_bw()
p

summary(lm(Observed ~ Infinite, data = df))
summary(lm(Observed ~ Finite, data = df))
```